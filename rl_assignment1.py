# -*- coding: utf-8 -*-
"""RL_Assignment1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YAg8M7mVZBA5XjKD46Hk1UTjF5RVDMQz
"""

import numpy as np
import matplotlib.pyplot as plt

# Constants
K = 5  # Number of articles
U = 4  # Number of user types
T1 = 1000  # Number of rounds for the first experiment
T2 = 10000  # Number of rounds for the second experiment

# Simulated click probabilities
click_probs = {
    (0, "female_over_25"): 0.8, (1, "female_over_25"): 0.6, (2, "female_over_25"): 0.5, (3, "female_over_25"): 0.4, (4, "female_over_25"): 0.2,
    (0, "male_over_25"): 0.2, (1, "male_over_25"): 0.4, (2, "male_over_25"): 0.5, (3, "male_over_25"): 0.6, (4, "male_over_25"): 0.8,
    (0, "under_25"): 0.2, (1, "under_25"): 0.4, (2, "under_25"): 0.8, (3, "under_25"): 0.6, (4, "under_25"): 0.5,
}

def simulate_click(article, user_type):
    # Map both "male_under_25" and "female_under_25" to "under_25" for probability lookup
    if user_type in ["male_under_25", "female_under_25"]:
        user_type = "under_25"
    prob = click_probs.get((article, user_type), 0)
    return np.random.random() < prob # Simulates the behaviour of a binomial, returns true if smaller, false if larger

def modified_ucb(T, K, U):
    n = np.zeros((K, U))
    successes = np.zeros((K, U))

    user_types = ["female_over_25", "male_over_25", "male_under_25", "female_under_25"]
    user_type_selections = np.random.choice(user_types, size=T)

    rewards = np.zeros(T)

    for t in range(1, T + 1):
        user_type = user_types.index(user_type_selections[t - 1])
        article_scores = np.zeros(K)

        for i in range(K):
            if n[i, user_type] == 0:
                article_scores[i] = float('inf')
            else:
                p_hat = successes[i, user_type] / n[i, user_type]
                confidence = np.sqrt((2 * np.log(t)) / n[i, user_type])
                article_scores[i] = p_hat + confidence

        chosen_article = np.argmax(article_scores)
        click = simulate_click(chosen_article, user_type_selections[t - 1])
        rewards[t - 1] = click

        n[chosen_article, user_type] += 1
        successes[chosen_article, user_type] += click

    cumulative_rewards = np.cumsum(rewards)
    optimal_rewards = np.array([max(click_probs[(k, "female_over_25" if ut in ["female_over_25"] else "male_over_25" if ut in ["male_over_25"] else "under_25")] for k in range(K)) for ut in user_type_selections]).cumsum()
    regret = optimal_rewards - cumulative_rewards

    return cumulative_rewards, regret

# Run the modified UCB algorithm for T=1000 rounds
cumulative_rewards_1, regret_corrected_1 = modified_ucb(T1, K, U)

# Run the modified UCB algorithm for T=10000 rounds
cumulative_rewards_2, regret_corrected_2 = modified_ucb(T2, K, U)

# Define the theoretical upper bound for expected regret
def theoretical_upper_bound(T, K=5, U=4):
    return np.sqrt(20 * T * np.log(T))

# Calculate the theoretical upper bound for T=1000
T1_values = np.arange(1, T1+1)
theoretical_regret_bound_1 = theoretical_upper_bound(T1_values)
# Calculate the theoretical upper bound for T=10000
T2_values = np.arange(1, T2+1)
theoretical_regret_bound_2 = theoretical_upper_bound(T2_values)

# Plotting experimental regret and theoretical upper bound
plt.figure(figsize=(12, 8))
plt.plot(regret_corrected_1, label="Experimental Regret")
plt.plot(T1_values, theoretical_regret_bound_1, label="Theoretical Upper Bound", linestyle='--')
plt.xlabel("Round (t)")
plt.ylabel("Regret")
plt.title("Comparing Experimental Regret and Theoretical Upper Bound for T=1000")
plt.legend()
plt.grid(True)

# Plotting experimental regret and theoretical upper bound
plt.figure(figsize=(12, 8))
plt.plot(regret_corrected_2, label="Experimental Regret")
plt.plot(T2_values, theoretical_regret_bound_2, label="Theoretical Upper Bound", linestyle='--')
plt.xlabel("Round (t)")
plt.ylabel("Regret")
plt.title("Comparing Experimental Regret and Theoretical Upper Bound for T=10000")
plt.legend()
plt.grid(True)

# Normalization of regret for T=1000 and T=10000
normalized_regret_1 = np.array([regret_corrected_1[t] / (t + 1) for t in range(T1)])
normalized_regret_2 = np.array([regret_corrected_2[t] / (t + 1) for t in range(T2)])


normalized_theoretical_regret_bound_1 = [theoretical_upper_bound(t) / t for t in T1_values]
normalized_theoretical_regret_bound_2 = [theoretical_upper_bound(t) / t for t in T2_values]

# Plotting for T=1000
plt.figure(figsize=(12, 8))
plt.plot(normalized_regret_1, label="Normalized Experimental Regret for T=1000")
plt.plot(T1_values, normalized_theoretical_regret_bound_1, label="Normalized Theoretical Upper Bound for T=1000", linestyle='--')
plt.xlabel("Round (t)")
plt.ylabel("Normalized Regret")
plt.title("Comparing Normalized Experimental Regret and Theoretical Upper Bound for T=1000")
plt.legend()
plt.grid(True)

# Plotting for T=10000
plt.figure(figsize=(15, 12))
plt.plot(normalized_regret_2, label="Normalized Experimental Regret for T=10000")
plt.plot(T2_values, normalized_theoretical_regret_bound_2, label="Normalized Theoretical Upper Bound for T=10000", linestyle='--')
plt.xlabel("Round (t)")
plt.ylabel("Normalized Regret")
plt.title("Comparing Normalized Experimental Regret and Theoretical Upper Bound for T=10000")
plt.legend()
plt.grid(True)

plt.show()